# S1.0Q 实验计划

> 日期：2026-02-13
> Baseline: StageB3_full checkpoint `model_3296.pt` (3296 iter, 1024 envs)
> 实验代号：`s1.0q`
> 前置实验：S1.0P（系统化单因素筛选，结论见 `s1.0p_experiment_summary_20260213.md`）
> 外部反馈：`s1.0p_feedback.md` + `s1.0p_feedback_2.md`

---

## 0. 核心战略转向

### S1.0P 的关键发现

S1.0P 做了 S/P/X 三组单因素实验，得出了明确的阶段性结论。但结合补充数据的 per-episode 漏斗分析后，发现一个更深层的问题：

| 口径 | frac_success | success_rate |
|------|:----------:|:-----------:|
| Step 加权（训练日志） | **0.31%** | — |
| Per-episode（诊断脚本） | — | **82.27%** |

**两套口径的矛盾揭示了真正的瓶颈**：17.6% 的失败 episode 贡献了 39.7% 的总 steps 和 57.9% 的 near steps。这些"深插+横向大偏差"的长尾失败 episode（平均 ~1000 步），把所有 step 加权指标整块吃掉了。

### 战略转向

| S1.0P 主线 | S1.0Q 主线 |
|-----------|-----------|
| 把 yaw 从 5.7° 磨到 5.0° | **消灭长尾失败 → 让 step 指标自然回正** |
| 调 hold 机制参数 | hold 已确认不是瓶颈，不再碰 |
| 全局调 k 值 | **分场景门控：近场降推进、升对齐** |

**核心假设**：长尾失败被消灭后，成功 episode（near-step yaw 均值 ≈ 2.79°）的权重将主导 step 统计，`yaw_deg_near_success` 有望从 5.7° 自然下降到 ≤ 4.0°，远超 5.0° 目标。

---

## 1. 实验目标与验收标准

### 1.1 主要 KPI（Per-Episode 口径，优先级从高到低）

| KPI | B0 当前值 | S1.0Q 目标 | 说明 |
|-----|----------|-----------|------|
| `fail_step_share` | 39.7% | **≤ 25%** | 失败 episode 占总 step 比例（核心指标） |
| `mean_fail_episode_len` | ~1000 steps | **≤ 400 steps** | 失败 episode 平均长度 |
| `per_episode_success_rate` | 82.27% | **≥ 85%** | Per-episode 成功率 |
| `yaw_deg_near_success` | 5.71° | **≤ 5.0°**（期望自然达标） | Step 加权 near-field yaw |
| `lateral_near_success` | 0.317 m | **≤ 0.25 m** | Step 加权 near-field lateral |

### 1.2 护栏指标（不可恶化）

| 护栏 | B0 当前值 | 底线 | 统计口径 |
|------|----------|------|---------|
| `per_episode_success_rate` | 82.27% | ≥ 80% | 离线 eval |
| `P(ever_deep)` | 93.92% | ≥ 90% | 离线 eval |
| `P(ever_near)` | 97.87% | ≥ 95% | 离线 eval |
| `insert_norm_mean` | 0.206 | ≥ 0.18 | 在线日志 |
| `mean_steps_to_first_near` | — | 不显著恶化 | 离线 eval |

> 新增 `P(ever_near)`、`P(ever_deep)`、`mean_steps_to_first_near` 用于区分"好的 fail 变短"（快速撤退重来）和"坏的 fail 变短"（索性不靠近），防止"假胜利"。

### 1.3 诊断指标补充

指标分两类：**在线日志**（per-step 可靠统计）和**离线 eval**（per-episode / 分位数统计）。

**在线日志**（`env.py` 日志输出）：

```python
"diag/deep_lat_bad_frac"      # insert_norm > 0.30 且 y_err > 0.20 的 step 比例
"s0/pen_dead_zone"             # 死区惩罚均值
"s0/r_retreat"                 # 撤退奖励均值
"s0/r_lat_fine"                # 横向精调奖励均值
```

**离线 eval**（扩展 `scripts/eval_s1.0p_diagnostics.py`，checkpoint 评估时运行）：

```python
"fail_step_share"              # 失败 episode 占总 step 比例（严格定义）
"mean_fail_episode_len"        # 失败 episode 平均长度
"per_episode_success_rate"     # Per-episode 成功率
"lateral_near_p90"             # 近场横向 p90
"yaw_near_p90"                 # 近场 yaw p90
"P(ever_near)"                 # Per-episode 曾到达 insert_norm > 0.1
"P(ever_deep)"                 # Per-episode 曾到达 insert_norm > 0.3
"mean_steps_to_first_near"     # 首次到达近场的平均步数
```

---

## 2. 实验组设计

采用 **A → B → C** 三组递进实验，外加 **D 组**（P2b seed 验证，可并行）：

```
D (P2b验证, 并行) ──────────────────────────────────────

A (消灭长尾) ──→ B (门控升级) ──→ C (横向精调+观测)
   A1: 死区惩罚       B1a: 仅改 ins_floor     C1: 横向delta shaping
   A2: 撤退鼓励       B1b: B1a+w_lat_gate     C2: 观测分辨率升级
   A3: A1+A2 组合     B2: A_best+B_best 组合
```

### 实验通用设置

| 参数 | 值 |
|------|-----|
| Resume from | `model_3296.pt` (3296 iter) |
| Fine-tune iters | 300 iter（与 S1.0P 一致） |
| Num envs | 1024 |
| Seed | 42（主 seed），关键组追加 2026、7 |

---

## 3. A 组：消灭长尾失败（最高优先级）

### 3.1 问题分析

失败 rollout 的典型模式（见 `s1.0p_rollout_A_deep_no_success.csv`）：

```
step 44:  insert_norm=0.10, y_err=0.524m  → 进入近场，但横向严重偏离
step 159: insert_norm=0.435, y_err=0.546m → 深插到碰撞上限，横向没有改善
step 1079: timeout                         → 在死区里原地磨到超时
```

当前奖励结构的问题：**策略在 `insert_norm > 0.30 & y_err > 0.20` 的"死区"里没有有效的负反馈**。`phi_ins` 的 `w_align3` 门控虽然存在，但不够强：

```python
# 当前 Stage3: w_align3 使用高斯软门控
w_align3 = exp(-(y_err/0.18)² - (yaw_err_deg/12.0)²)
phi_ins = k_ins * (0.4 + 0.6 * w_align3) * insert_norm * w3
```

当 `y_err = 0.5m` 时，`w_align3 ≈ 0`，但 `phi_ins` 仍有 **40% 的底线信号**（`0.4 * insert_norm`），策略仍然能在死区里拿到插入进度的"奖学金"。

### 3.2 A1: 深插死区惩罚

**改动**：在 `insert_norm > 0.30` 且 `y_err > 0.20` 时，每步给一个显式负奖励。

```python
# ---- S1.0Q-A1: 深插死区惩罚 ----
dead_zone = (insert_norm > self.cfg.dead_zone_insert_thresh) & \
            (y_err > self.cfg.dead_zone_lat_thresh)
# 线性惩罚：越深越偏，惩罚越重
pen_dead_zone = -self.cfg.k_dead_zone * dead_zone.float() * \
    (insert_norm - self.cfg.dead_zone_insert_thresh) * \
    (y_err - self.cfg.dead_zone_lat_thresh)
# 硬 clamp 护栏：防止极端状态下惩罚爆炸
pen_dead_zone = torch.clamp(pen_dead_zone, min=-self.cfg.dead_zone_pen_clamp, max=0.0)
```

**新增参数**（`env_cfg.py`）：

| 参数 | 值 | 说明 |
|------|-----|------|
| `dead_zone_insert_thresh` | 0.30 | 死区插入阈值（归一化） |
| `dead_zone_lat_thresh` | 0.20 | 死区横向阈值 (m) |
| `k_dead_zone` | 0.5 | 死区惩罚权重（初始保守，后续可调） |
| `dead_zone_pen_clamp` | 0.05 | 每步最大惩罚绝对值 |

**预期效果**：
- 失败 episode 的平均长度从 ~1000 步缩短到 ~400 步（早停或策略主动避免深插）
- `fail_step_share` 从 39.7% 降到 ≤ 30%

**验收标准**：
- 主判据：`fail_step_share` 净减少 ≥ 5%（绝对值）
- 护栏：`per_episode_success_rate` ≥ 80%

---

### 3.3 A2: 撤退鼓励 shaping

**改动**：在死区内，给 `insert_norm` 下降（退出来）一个正的 delta shaping 信号。

```python
# ---- S1.0Q-A2: 死区撤退鼓励 ----
in_dead_zone = (insert_norm > self.cfg.dead_zone_insert_thresh) & \
               (y_err > self.cfg.dead_zone_lat_thresh)
# insert_norm 下降 → delta 为负 → 取反变正奖励
delta_insert = insert_norm - self._prev_insert_norm  # (N,)
# 关键修正：用上一帧的死区状态 gate，确保"退出死区的最后一步"也能拿到奖励
r_retreat = torch.where(
    self._prev_in_dead_zone,
    -self.cfg.k_retreat * delta_insert,  # 退出 → delta<0 → reward>0
    torch.zeros_like(delta_insert)
)
r_retreat = torch.where(self._is_first_step, torch.zeros_like(r_retreat), r_retreat)
# 硬 clamp 护栏
r_retreat = torch.clamp(r_retreat, min=0.0, max=self.cfg.retreat_reward_clamp)
# 更新 prev 状态
self._prev_insert_norm = insert_norm.detach()
self._prev_in_dead_zone = in_dead_zone.detach().clone()
```

> **gating 修正说明**：用 `_prev_in_dead_zone`（上一帧的死区标记）而非当前帧 `in_dead_zone` 做 gate。
> 否则当策略从 `insert_norm=0.31` 退到 `0.29` 时，当前帧已不在 dead zone，这关键一步就拿不到奖励。

**新增参数**：

| 参数 | 值 | 说明 |
|------|-----|------|
| `k_retreat` | 2.0 | 撤退鼓励权重（需要足够强，与 `phi_ins` 的量级竞争） |
| `retreat_reward_clamp` | 0.1 | 每步最大撤退奖励 |

**预期效果**：
- 策略学会在死区里"后退 → 重新对齐横向 → 再前进"
- 比纯惩罚更有建设性：不只是说"别在这"，还说"怎么出去"

**验收标准**：
- 主判据：`mean_fail_episode_len` 减少 ≥ 200 步
- 辅助：`deep_lat_bad_frac`（死区 step 比例）下降

---

### 3.4 A3: A1 + A2 组合

**改动**：同时启用 A1 死区惩罚 + A2 撤退鼓励。

**理由**：A1 告诉策略"你在错误的井里越挖越亏"，A2 告诉策略"怎么爬出来"。两者互补。

**验收标准**：
- 主判据：`fail_step_share` ≤ 28%（综合效果应优于 A1/A2 单独）
- 护栏：`per_episode_success_rate` ≥ 80%

---

### 3.5 Milestone 门控补丁（A 组配套）

**问题**：`milestone_insert10`（+5 分）和 `milestone_insert30`（+10 分）仅检查 `insert_norm`，无对齐门控。在死区（`y_err > 0.20m`）内策略仍可拿到 15 分里程碑奖励，绕过了 A 组的门控。

**改动**：在死区内衰减 milestone 奖励。A 组实验统一启用此补丁。

```python
# ---- S1.0Q: Milestone 死区衰减 ----
in_dead_zone_now = (insert_norm > self.cfg.dead_zone_insert_thresh) & \
                   (y_err > self.cfg.dead_zone_lat_thresh)
milestone_reward = torch.where(
    in_dead_zone_now,
    milestone_reward * self.cfg.milestone_dead_zone_scale,
    milestone_reward
)
```

**新增参数**：

| 参数 | B0 值 | A 组值 | 说明 |
|------|-------|--------|------|
| `milestone_dead_zone_scale` | 1.0（不衰减） | **0.0** | 死区内 milestone 完全屏蔽 |

---

## 4. B 组：插入进度门控升级

### 4.1 问题分析

当前 Stage3 的 `phi_ins` 有一个 40% 的底线（`0.4 + 0.6 * w_align3`），这意味着即使 `w_align3 = 0`（横向完全偏离），策略仍然能从插入深度增加中获得可观的正奖励。这是策略"横向偏着也猛插"的根本原因。

### 4.2 B1a: 仅降低插入底线（单因素）

**改动**：将 Stage3 `phi_ins` 的硬编码 0.4 底线改为可配置 `ins_floor`，降到 0.1。

```python
# ---- S1.0Q-B1a: 仅改 ins_floor ----
# 原来：phi_ins = k_ins * (0.4 + 0.6 * w_align3) * insert_norm * w3
# B1a：phi_ins = k_ins * (ins_floor + (1.0 - ins_floor) * w_align3) * insert_norm * w3
phi_ins = self.cfg.k_ins * (self.cfg.ins_floor + (1.0 - self.cfg.ins_floor) * w_align3) \
          * insert_norm * w3 * w_lat_gate
```

> `w_lat_gate` 在 B1a 中 = 1.0（`ins_lat_gate_sigma=1e6`，不生效），实际只改了 `ins_floor`。

**参数设置**：

| 参数 | B0 值 | B1a 值 | 说明 |
|------|-------|--------|------|
| `ins_floor` | 0.4 | **0.1** | Stage3 底线降低到 10% |
| `ins_lat_gate_sigma` | 1e6 | 1e6 | 不生效 |

**预期效果**：
- 当 `y_err = 0.5m` 时，`w_align3 ≈ 0`，`phi_ins` 从 40% 底线降到 10% 底线
- 减少"misaligned 时的保底插入奖学金"，但不完全断掉

**验收标准**：
- 主判据：`lateral_near_success` 下降 ≥ 0.02 m
- 护栏：`P(ever_deep)` ≥ 90%

---

### 4.3 B1b: 底线 + 横向独立门控（在 B1a 基础上）

**改动**：在 B1a 的基础上，额外添加横向指数衰减因子 `w_lat_gate`。

```python
# ---- S1.0Q-B1b: ins_floor + w_lat_gate ----
w_lat_gate = torch.exp(-(y_err / self.cfg.ins_lat_gate_sigma) ** 2)
phi_ins = self.cfg.k_ins * (self.cfg.ins_floor + (1.0 - self.cfg.ins_floor) * w_align3) \
          * insert_norm * w3 * w_lat_gate
```

> 注意 `w_align3` 本身已包含 `y_err` 的高斯门控（σ=0.18m），再乘 `w_lat_gate`（σ=0.20m）等于"门控叠门控"，有效 σ 会变小。需观察是否过于激进。

**参数设置**：

| 参数 | B0 值 | B1b 值 | 说明 |
|------|-------|--------|------|
| `ins_floor` | 0.4 | **0.1** | Stage3 底线降低到 10% |
| `ins_lat_gate_sigma` | 1e6 | **0.20** | 横向独立门控 σ (m) |

**预期效果**：
- 当 `y_err = 0.5m` 时，`w_lat_gate ≈ 0`，插入进度奖励几乎归零
- 当 `y_err = 0.1m` 时，`w_lat_gate ≈ 0.78`，基本不影响正常路径

**验收标准**：
- 主判据：`lateral_near_success` 下降 ≥ 0.03 m
- 护栏：`P(ever_deep)` ≥ 90%

> **B1a vs B1b 的对比意义**：拆开后可判断到底是"底线太高"（B1a 就够）还是"门控不够硬"（需要 B1b）。

---

### 4.4 B2: A_best + B_best 组合

**改动**：在 A 组最佳（A3 或 A1/A2 中效果更好者）基础上叠加 B 组最佳（B1a 或 B1b）。

**理由**：A 组消灭已在死区里的长尾，B 组阻止策略进入死区。上下游互补。

**验收标准**：
- 综合判据：`fail_step_share` ≤ 25% **且** `lateral_near_success` ≤ 0.28 m
- 护栏：`per_episode_success_rate` ≥ 80%

---

## 5. C 组：横向精调 + 观测分辨率

### 5.1 问题分析

补充数据显示：
- `y_err_obs` 归一化尺度 = 0.5 m，在近场（`y_err < 0.15m`）只使用了 [-0.3, 0.3] 的动态范围
- `yaw_err_obs` 归一化尺度 = 15°，在近场（`yaw < 5°`）只使用了 [-0.33, 0.33] 的动态范围
- 现有 `r_hold_align` 是 yaw + lateral 联合高斯的 delta shaping，但量级只有总奖励的 ~1%

### 5.2 C1: 横向 delta shaping（r_lat_fine）

**改动**：新增独立的横向 delta shaping，对标 X 组的 `r_yaw_fine` 思路。

```python
# ---- S1.0Q-C1: 横向 delta shaping ----
# 只在近场（insert_norm > 0.05）激活
lat_fine_active = insert_norm > self.cfg.lat_fine_ins_thresh
phi_lat = torch.exp(-(y_err / self.cfg.lat_fine_sigma) ** 2)
r_lat_fine = self.cfg.k_lat_fine * (phi_lat - self._prev_phi_lat)
r_lat_fine = torch.where(
    lat_fine_active & ~self._is_first_step,
    r_lat_fine,
    torch.zeros_like(r_lat_fine)
)
self._prev_phi_lat = phi_lat.detach()
```

**新增参数**：

| 参数 | 值 | 说明 |
|------|-----|------|
| `k_lat_fine` | 0.8 | 横向 delta shaping 权重（比 `k_hold_align=0.3` 更强） |
| `lat_fine_sigma` | 0.15 | 横向高斯尺度 (m)，与成功阈值对齐 |
| `lat_fine_ins_thresh` | 0.05 | 激活门槛（归一化 insert_norm） |

**预期效果**：
- 在近场给策略一个"横向每缩小 1cm 就有回报"的持续梯度
- 不依赖 yaw（独立通道），避免 yaw/lat 梯度互相干扰

**验收标准**：
- 主判据：`lateral_near_success` 下降 ≥ 0.04 m
- 辅助：`r_lat_fine_mean` 量级达到总奖励的 ≥ 3%

---

### 5.3 C2: 观测分辨率升级

**改动**：收窄 `y_err_obs` 和 `yaw_err_obs` 的归一化尺度，提高近场分辨率。

```python
# ---- S1.0Q-C2: 观测分辨率升级 ----
# 原来：y_err_obs = clip(y_signed / 0.5, -1, 1)
# 新增：y_err_fine = clip(y_signed / 0.2, -1, 1)  → 近场分辨率提升 2.5 倍
# 原来：yaw_err_obs = clip(dyaw / deg2rad(15), -1, 1)
# 新增：yaw_err_fine = clip(dyaw / deg2rad(8), -1, 1)  → 近场分辨率提升 1.875 倍
```

**修改 `_get_observations()`**：

| 观测维度 | 旧定义 | 新定义 | 说明 |
|---------|--------|--------|------|
| dim 13 | `y_err_obs = clip(y/0.5, -1, 1)` | 保留 | 粗尺度不变 |
| dim 14 | `yaw_err_obs = clip(dyaw/15°, -1, 1)` | 保留 | 粗尺度不变 |
| **dim 15（新增）** | — | `y_err_fine = clip(y/0.2, -1, 1)` | 近场高分辨率横向 |
| **dim 16（新增）** | — | `yaw_err_fine = clip(dyaw/8°, -1, 1)` | 近场高分辨率偏航 |

> **观测维度从 15 → 17**。由于增加了 2 维观测，此组需要**从头训练**（或用兼容 warm start：新维度第一层权重初始化为 0）。

**兼容 Warm Start 方案**（推荐）：

必须同步完成以下 3 项工程改动：

1. **Actor 和 Critic 第一层都要扩维**（actor/critic 分开网络）：
```python
# 加载旧 checkpoint 后，对 actor 和 critic 第一层做扩展
for prefix in ['actor', 'critic']:
    key = f'{prefix}.0.weight'
    old_weight = state_dict[key]  # (256, 15)
    new_weight = torch.zeros(256, 17)
    new_weight[:, :15] = old_weight
    state_dict[key] = new_weight
    # bias 不变
```

2. **Obs running mean/std 重置**：当前已开启 `actor_obs_normalization=True` / `critic_obs_normalization=True`。新增 2 维后需重置 running stats（mean=0, var=1），否则新维度的归一化统计会被旧分布污染。

3. **Done mask 重置新增 prev 变量**：`_prev_insert_norm`、`_prev_phi_lat`、`_prev_in_dead_zone` 需要在 `_reset_idx` 中按 `env_ids` 重置（1024 env 并行，某些 done 另一些未 done，必须按 mask 重置对应 index，防止 shaping 跨 episode 串味）。

**验收标准**：
- 主判据：`yaw_deg_near_success` ≤ 5.0°，`lateral_near_success` ≤ 0.25 m
- 护栏：训练稳定性（loss 不爆炸、`insert_norm_mean` 不断崖）

**特别说明**：C2 的训练迭代数可能需要延长到 500 iter（新增维度需要更多训练消化）。

---

## 6. D 组：P2b 多 Seed 验证（与 A/B/C 并行）

### 6.1 目的

S1.0P 中 P2b（gate3 收紧到 6°/0.10m）在 seed=42 下表现最佳：
- `yaw_deep` 趋势 **-0.32°**（全实验最强）
- `yaw_near` 约 **-0.20°**（踩线达标）

但只有 1 个 seed，需要验证是否可复现。

### 6.2 实验配置

| 参数 | 值 |
|------|-----|
| 变更 | `yaw_gate3 = 6.0°`, `y_gate3 = 0.10 m` |
| Seeds | **42, 2026, 7** |
| Fine-tune iters | 300 iter |
| 其余参数 | 与 B0 一致 |

### 6.3 验收标准

- 3 个 seed 中 ≥ 2 个 `yaw_near` 改善方向一致（Δ < 0）
- 改善幅度均值 ≥ -0.15°
- 若验证通过，P2b 的 gate3 设置可作为 **S1.0Q 新 baseline 结构**的候选

---

## 7. 分支策略与实验方法论

### 7.1 Git 分支策略：一套代码 + 参数覆盖

不再为每个实验创建独立代码分支，改为**一个功能分支 + 运行脚本传参**：

```
master ─────────────────────────────────────────────
   │
   └─► feat/s1.0q  （唯一代码分支，所有新功能默认关闭）
```

- 从 `master` 创建 `feat/s1.0q`，包含所有 S1.0Q 新代码
- **所有新参数的默认值保持 B0 行为**：`ins_floor=0.4`、`k_retreat=0.0`（默认不激活）、`k_lat_fine=0.0`、`ins_lat_gate_sigma=1e6`（不生效）、`milestone_dead_zone_scale=1.0`
- 各实验通过运行脚本传参覆盖来激活对应功能

### 7.2 `env_cfg.py` 新增参数（默认值 = B0 行为）

```python
# ---- S1.0Q: 死区惩罚 (A1) ----
dead_zone_insert_thresh: float = 0.30
dead_zone_lat_thresh: float = 0.20
k_dead_zone: float = 0.5
dead_zone_pen_clamp: float = 0.05      # 每步最大惩罚绝对值

# ---- S1.0Q: 撤退鼓励 (A2) ----
k_retreat: float = 0.0                  # B0=0（不激活）; A2 改为 2.0
retreat_reward_clamp: float = 0.1       # 每步最大撤退奖励

# ---- S1.0Q: Milestone 死区衰减 ----
milestone_dead_zone_scale: float = 1.0  # B0=1.0（不衰减）; A 组改为 0.0

# ---- S1.0Q: 插入进度门控 (B1) ----
ins_floor: float = 0.4                  # B0=0.4（原硬编码）; B1a 改为 0.1
ins_lat_gate_sigma: float = 1e6         # B0=无穷大（不生效）; B1b 改为 0.20

# ---- S1.0Q: 横向精调 (C1) ----
k_lat_fine: float = 0.0                 # B0=0（不激活）; C1 改为 0.8
lat_fine_sigma: float = 0.15
lat_fine_ins_thresh: float = 0.05

# ---- S1.0Q: 观测分辨率 (C2) ----
y_err_fine_scale: float = 0.20
yaw_err_fine_scale_deg: float = 8.0
```

### 7.3 参数覆盖矩阵

各实验的参数覆盖（`x` = 改动，空 = B0 默认）：

| 参数 | B0 | A1 | A2 | A3 | B1a | B1b | B2 | C1 |
|------|:--:|:--:|:--:|:--:|:---:|:---:|:--:|:--:|
| `k_dead_zone` (0.5) | | x | | x | | | x | |
| `dead_zone_pen_clamp` (0.05) | | x | | x | | | x | |
| `k_retreat` (0→2.0) | | | x | x | | | x | |
| `retreat_reward_clamp` (0.1) | | | x | x | | | x | |
| `milestone_dead_zone_scale` (1→0) | | x | | x | | | x | |
| `ins_floor` (0.4→0.1) | | | | | x | x | x | |
| `ins_lat_gate_sigma` (1e6→0.2) | | | | | | x | | |
| `k_lat_fine` (0→0.8) | | | | | | | | x |

### 7.4 单因素 → 多因素组合实验方法论

#### 阶段一：单因素实验（第一批并行）

每个实验只改变 **一个功能模块**，其余参数保持 B0 默认。目的是隔离每个改动的独立贡献。

```
A1:  只开死区惩罚 + milestone 衰减  → 量化"惩罚死区"的独立效果
A2:  只开撤退鼓励                    → 量化"鼓励撤退"的独立效果
B1a: 只改 ins_floor                  → 量化"降低插入底线"的独立效果
D:   只改 gate3 参数                  → P2b seed 验证
```

**对照基线**：每个实验 vs B0（S1.0P 的 `model_3296.pt` + 300 iter），用离线 eval 脚本统一评估。

**单因素判定标准**：
- 主 KPI 改善方向与预期一致（如 A1 → `fail_step_share` 下降）
- 护栏指标未恶化（`per_episode_success_rate` ≥ 80%，`P(ever_deep)` ≥ 90%）
- 若两者都满足 → 标记为"有效"

#### 阶段二：正交性检验（第二批）

将阶段一中"有效"的单因素组合，检验是否存在正交加成或互相干扰。

```
A3 = A1 + A2:
  预期：效果叠加（A1 惩罚死区 + A2 引导撤退，作用于不同行为阶段）
  判定正交：A3 效果 ≥ max(A1, A2) 的 80%
  判定干扰：A3 效果 < min(A1, A2) → 说明互相抵消，需分析原因
```

#### 阶段三：跨组组合（第三/四批）

将 A 组最佳（消灭死区）与 B 组最佳（防止进入死区）组合：

```
B2 = A_best + B_best:
  预期：上游（B 阻止进死区）+ 下游（A 消灭已进死区的长尾）互补
  判定正交：B2 的 fail_step_share ≤ A_best 且 lateral_near ≤ B_best
  判定干扰：某项指标反而恶化 → 说明奖励信号冲突，需调参或二选一
```

#### 阶段四：精修叠加（第五批，视前面结果决定）

```
C1/C2: 在前面最佳组合基础上叠加横向精调/观测扩维
  只有在 B2 的 lateral_near_success 仍 > 0.25m 时才启动
```

### 7.5 统一对比表模板

每个实验完成后在以下表格中追加一行（在 s1.0q 实验总结文档中维护）：

| 实验 | 类型 | 改动因素 | fail_step | mean_fail | success | lat_near | yaw_near | ever_deep | 结论 |
|------|------|---------|-----------|-----------|---------|----------|----------|-----------|------|
| B0 | 基线 | — | 39.7% | ~1000 | 82.27% | 0.317m | 5.71° | 93.92% | — |
| A1 | 单因素 | 死区惩罚 | | | | | | | |
| A2 | 单因素 | 撤退鼓励 | | | | | | | |
| B1a | 单因素 | ins_floor→0.1 | | | | | | | |
| A3 | 组合 | A1+A2 | | | | | | | |
| B1b | 单因素 | B1a+w_lat_gate | | | | | | | |
| B2 | 组合 | A_best+B_best | | | | | | | |
| C1 | 单因素 | 横向delta shaping | | | | | | | |

### 7.6 `env.py` 改动位置

| 位置 | 改动 | 实验组 |
|------|------|--------|
| `__init__()` | 新增 `_prev_insert_norm`, `_prev_phi_lat`, `_prev_in_dead_zone` | A2/C1 |
| `_reset_idx()` | 按 `env_ids` 重置上述 3 个变量 | A2/C1 |
| `_get_rewards()` L962 | `phi_ins` 硬编码 0.4 → `ins_floor` + `w_lat_gate` | B1 |
| `_get_rewards()` ~L1030 后 | Milestone 死区衰减 | A1 |
| `_get_rewards()` ~L1120 前 | 新增 `pen_dead_zone` / `r_retreat` / `r_lat_fine` | A1/A2/C1 |
| `_get_rewards()` L1123 | 总奖励加入新项 | 全组 |
| `_get_rewards()` ~L1206 后 | 新增诊断日志 | 全组 |
| `_get_observations()` | 新增 dim 15-16（C2 专用） | C2 |

---

## 8. 执行顺序与资源规划

### 8.1 执行优先级

```
第一批（并行，立即启动 — 同时打上游 + 下游）:
├── A1:  死区惩罚            (~2h, 300 iter, seed=42)
├── A2:  撤退鼓励            (~2h, 300 iter, seed=42)
├── B1a: ins_floor 0.4→0.1   (~2h, 300 iter, seed=42)  ← 上游止血
├── D-s2026: P2b seed=2026   (~2h, 300 iter)
└── D-s7:    P2b seed=7      (~2h, 300 iter)

第二批（第一批结果出来后）:
├── A3:  A1+A2 组合           (~2h, 300 iter, seed=42)
└── B1b: B1a+w_lat_gate       (~2h, 300 iter, seed=42)

第三批（A3/B1 结果对比后）:
├── B2:  A_best+B_best 组合   (~2h, 300 iter, seed=42)
└── C1:  横向 delta shaping   (~2h, 300 iter, seed=42)

第四批（视前面结果决定）:
└── C2:  观测分辨率升级        (~4h, 500 iter, warm start)
```

### 8.2 每批实验后的决策节点

| 批次 | 决策 |
|------|------|
| 第一批后 | A1/A2/B1a 哪个最有效？是否都有效？D 组 P2b seed 验证是否通过？ |
| 第二批后 | A3 效果是否优于 A1/A2 单独？B1b 是否优于 B1a？→ 确定 A_best 和 B_best |
| 第三批后 | B2 组合效果是否正交叠加？C1 横向 shaping 量级是否足够？ |
| 第四批后 | 全面对比，选出 S1.0Q 最终 baseline；决定 C2 是否值得投资 |

---

## 9. 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|---------|
| A1 惩罚过强 → 策略不敢接近托盘 | 中 | `P(ever_deep)` 下降 | 硬 clamp（每步 ≤ 0.05），k=0.5 保守起步 |
| A2 撤退 → 策略原地反复进退 | 中 | 新的 exploit 模式 | 硬 clamp（每步 ≤ 0.1），结合 stall 早停 |
| Milestone 绕过门控 | 中 | A/B 组效果被里程碑抵消 | A 组统一启用 `milestone_dead_zone_scale=0` |
| B1 门控太紧 → 插入进度慢 | 低 | 训练不稳定 | B1a/B1b 拆分对比，B1a 保守先行 |
| C2 warm start 不兼容 | 低 | 新维度权重被旧分布污染 | actor+critic 同步扩维 + obs norm 重置 |
| 长尾消除后 yaw 没有自然下降 | 低 | 需要继续做 yaw 专项 | D 组 P2b 验证 + C1 横向 shaping 作为备手 |

---

## 10. 与 S1.0P 反馈的对应关系

| 反馈建议 | 对应实验组/章节 | 备注 |
|---------|-----------|------|
| 深插-大横偏惩罚（feedback_2 优先级 A.1） | **A1** | 完全采纳 |
| 允许/鼓励撤退（feedback_2 优先级 A.2） | **A2** | 完全采纳 |
| 插入进度 lateral 门控（feedback_2 优先级 B.3） | **B1a/B1b** | 采纳，拆分为两步验证 |
| r_lat_fine 横向 delta shaping（feedback_2 优先级 C.4） | **C1** | 完全采纳 |
| P2b seed 验证（feedback_1 Step 1） | **D** | 完全采纳 |
| 观测分辨率升级（feedback_1 Step 4） | **C2** | 采纳，补全 warm start 工程清单 |
| 修正验收标准口径（feedback_2 第 5 节） | **§1.1** | 改用 per-episode 口径 |
| 漏斗分解（feedback_1 Step 2） | **§1.3** | 在线/离线分开，不再"近似" |
| 近场 reweight（feedback_1 Step 3） | B1 + C1 协同 | 间接实现 |
| 课程学习（feedback_1 Step 5） | S1.0Q 不做 | 先用结构性改动验证效果 |
| A2 gating 修正（plan_feedback #2） | **§3.3** | 改用 `prev_in_dead_zone` |
| Reward 硬 clamp（plan_feedback #3） | **§3.2/§3.3** | `pen_dead_zone` / `r_retreat` 加 clamp |
| B1 拆分（plan_feedback #4） | **§4.2/§4.3** | 拆为 B1a/B1b 独立对比 |
| Milestone 门控（plan_feedback #5） | **§3.5** | 死区内 milestone 衰减 |
| 防自欺指标（plan_feedback #8） | **§1.2** | 新增 `P(ever_near/deep)` |
| 分支策略（plan_feedback #7） | **§7.1** | 一套代码 + 参数覆盖 |

---

## 11. 一句话总结

S1.0Q 的核心打法是 **"先灭火（消灭长尾失败）→ 再堵漏（阻止进入死区）→ 最后精修（横向 shaping + 观测升级）"**。

长尾失败就像一个 17.6% 人数但 39.7% 权重的"吸血鬼"，只要它倒下，yaw/lateral/frac_success 这三个 step 级 KPI 都会同步改善，属于"一刀切三条 KPI"的收益。
