根据 2026-02-13 的《S1.0P 实验总结报告》，你这轮实验的主线很清晰：先排除“物理做不到/动作噪声导致抖动”，再用 S/P/X 三组单因素调参去啃两个 KPI：近场 yaw 精度（~5.7°→≤5.0°）和 `frac_success`（~0.3%）。

我把你压缩包里的补充数据（episode_stats、两个 rollout、diagnostics 脚本）也一并对齐看了一遍后，结论会更“尖锐”一点：

**你现在真正卡住的不是“hold 能不能稳住”，也不只是“yaw 还差 0.7°”，而是一个更像工程系统里常见的怪物：少量“深插 + 横向大偏差”的长尾失败，把近场统计量和吞吐率（step 级 KPI）整块吃掉了。**

---

## 1) 先把 KPI 解释对：你看到的 0.3% 并不等于“每局几乎不成功”

报告里 B0 的关键数是：`frac_success=0.0031`、`yaw_deg_near_success=5.71°`、`lateral_near_success=0.317m`、`near_success_frac=60.4%`、`deep_insert_frac=39.7%`。

结合补充包的数据，一个很关键的对齐点是：

* 报告里的这些 “*_frac / *_mean” **本质上是 step 加权**的统计（在 near 条件下的平均、在全体 step 中的比例），不是“每个 episode 是否达成”的概率。
* 你压缩包里做的那套漏斗（per-episode “是否曾达到过”）显示：
  **近场(ever_near) 97.87%**、**深插(ever_deep) 93.92%**、**最终 success 82.27%**（以 episode 计）。

这两套口径看起来矛盾，但其实是同一件事的两面：
**少数失败 episode 特别长（接近 timeout），所以它们在 step 统计里权重大得离谱。**

---

## 2) “S 组全军覆没”其实是合理结果，但理由需要升级一下

报告里的结论是：S 组调 hold 机制（decay/hysteresis/steer_smooth）对 `frac_success` 影响都在噪声里，因此瓶颈不在 hold 容错性。

补充数据把这个结论“钉死”得更牢（而且更具体）：

* **一旦进了 grace/开始累计 hold，几乎都会成**：ever_grace 82.40%，success 82.27%，差值只有 0.13%（在 3620 局里大约 5 局）。
* 也就是说：**hold 的稳定性不是主战场**；主战场是“怎么更频繁、更快地进入 hold 条件”。

你报告里用 `hold_counter_max~9.76（需≥10）` 去解释“差一口气”那段，也提示了这个方向。
但补充包里从 episode 统计看，success 的触发点更像是 **hold_counter 到 9 左右就终止**（这会让“差 10”那种解读产生偏差）。这点我建议你在 env 里把 `_hold_steps` 的实际值打印/记录一下（下面我会说要补充什么资料）。

---

## 3) 真正的“罪魁祸首”：深插卡死 + 横向大偏差的长尾

用你压缩包的 episode_stats 重新拆分后，现象非常像一个“吸血鬼模式”：

* **失败局只占 17.6%（1 - 82.27%）**，但它们贡献了

  * **39.7% 的总 steps**
  * **57.9% 的 near steps**
* 成功局 vs 失败局（近场 step 加权）对比极端：

  * 成功局 near-step 平均 yaw ≈ **2.79°**，平均 lateral ≈ **0.075m**
  * 失败局 near-step 平均 yaw ≈ **7.59°**，平均 lateral ≈ **0.404m**

所以你看到的 `yaw_deg_near_success~5.7°`、`lateral_near_success~0.317m`，很大概率不是“所有 episode 都差一点点”，而是**“失败长尾把均值拉坏了”**。这也解释了为什么你在 P/X 组里拼命给 yaw shaping，常常出现“短期能压下去、长训又回弹”的均衡点现象。

### 你给的失败 rollout（deep_no_success）非常典型

它的行为模式是：

* 很快就深插到 insert_norm≈0.43（接近你统计里“深插上限被碰撞卡住”的那一坨）
* **y_err 一直在 ~0.52–0.55m**，完全没进对齐门槛（0.15m）附近
* lift 基本不动
* drive/steer 进入一种“固定点”——像是在对着空气打方向盘，实际上状态没改善，然后拖到 timeout

这说明当前策略缺一个关键“反射弧”：

> **如果深插了但横向偏得离谱：要么早点别插这么深，要么及时退出来重来。**
> 现在它在“深插+横向大偏差”的死区里没有有效的自救策略。

---

## 4) 下一步怎么做：把火力从“继续磨 yaw 0.7°”转向“消灭长尾失败”

你报告里已经判断“奖励信号被主奖励淹没”——r_hold_align / r_yaw_fine 只有总奖励的 1–2% 量级，PPO 梯度里几乎不可见。
我同意这个诊断，但我要补一句：**你需要放大的不止 yaw，还得放大 lateral，并且要专打“深插死区”。**

### 我建议的 S1.0Q 优先级（按性价比）

#### 优先级 A：先把“长尾失败”变短（不然任何均值 KPI 都会被它污染）

1. **深插-大横偏惩罚（强烈建议）**
   当 `insert_norm > 0.30` 且 `y_err > 0.20`（阈值可调）时，每步给一个明确的负奖励（线性或二次），让策略知道“你现在在错误的井里越挖越亏”。

   * 目标：把那批 1000+ step 的失败局压缩掉（哪怕先压成 200 step 失败也赚，因为它们权重太大）。

2. **“允许/鼓励撤退”的形状奖励**
   只惩罚可能会让它学会“别靠近”，但未必学会“怎么脱困”。
   所以在上述死区里，给一个“撤退可得分”的势函数差分：

   * 若处于 `insert_norm>0.30 & y_err>0.20`，则 **insert_norm 下降**（退出来）给正的 delta shaping；
   * 一旦 y_err 回到较小，再允许 forward/insert shaping 重新变香。

这两条是“工程上最快见效”的，因为它们直接砍掉拖累 step 指标的最长尾。

---

#### 优先级 B：让策略“插之前先对齐横向”，避免进死区

3. **对插入进度奖励做 lateral 门控（很关键）**
   你现在 P2a/P2b 的 gate3 是在更后段收紧 yaw/y。
   但从失败样本看：**它在横向大偏差时照样能深插到碰撞上限**，然后就死。
   所以我建议把门控前移到“insert 进度 shaping”本身：

   * 例如：`r_insert_pot *= exp(-(y_err / σy)^2)`（σy 取 0.15 或 0.20 一档）
   * 或者更粗暴：`if y_err>0.20: r_insert_pot=0`
     直觉：**你横向没对上，往里怼不应该拿到“进度奖学金”。**

---

#### 优先级 C：补“横向精调”的可学习梯度（对应你 X 组 yaw_fine 的思路）

4. **做一个 r_lat_fine（横向 delta shaping），对标 r_yaw_fine**
   你已经做了 yaw 的 `phi=exp(-(yaw/σ)^2)` 差分 shaping。
   同理给 lateral 做一个：

   * `phi_lat = exp(-(y_err/σy)^2)`
   * `r_lat_fine = k_lat * (phi_t - phi_{t-1})`
   * 激活区间可以放在 `insert_norm > 0.05` 或 `>0.10`
     这会显著提高“往正确方向一点点挪”的梯度可见性。

---

#### 优先级 D：再回头看 yaw（但这次你会更容易达标）

当长尾失败被压掉后，你的 `yaw_deg_near_success` 很可能**自然下降**，因为失败局的 near-step yaw 均值大约 7.6°，它们是均值的主要污染源。
这时候再去做你报告里提到的：

* P2b seed 验证（低成本）
* 或更高分辨率观测（yaw_err_fine / lateral_err_fine）
  会更“顺风”，不容易被长尾拖着跑。

---

## 5) 我建议你把验收标准也顺手修一下（不然会出现“怎么都不可能达标”的假象）

你在 S 组写的是：`frac_success` 净增益 ≥ **+3%（绝对值）**。
但 `frac_success` 当前量级是 0.0031（0.31%）。

如果它是 step 口径（很像），那么“+3% 绝对值”会要求它从 0.31% 跳到 3.31%——这通常意味着 episode 平均长度要短到几十步级别，基本不现实（除非任务/终止逻辑大改）。
更合理的做法是：

* 用 **per-episode 成功率**（success_rate）做主判据（你补充包已经算出来了）
* 或者用 `mean_steps_to_success / fail_step_share / near_steps_fail_share` 这类指标，把“长尾失败拖累”显式纳入验收

否则会出现一种很荒诞的情况：你明明把失败局从 1000 步压到 200 步，系统吞吐率大涨，但因为口径不对，验收仍然显示“无改善”。

---

## 6) 你如果还能再补几样资料，我可以把“下一轮改什么”写成更像可直接落地的 patch 清单

压缩包已经很有用了。为了把建议从“方向”变成“开箱即用的改动点”，我最想要的是下面这些（按信息密度排序）：

1. **env.py / reward 计算的核心片段**

   * r_pot / r_milestone / pen_dense / r_hold_align / gate 逻辑（尤其是 insert 进度奖励到底怎么给的、有没有 clamp、有没有在碰撞时变化）
     你报告里已经量级对比过奖励分量，但我需要看到具体公式，才能准确告诉你“把哪一项乘门控、k 该从 0.5 改到多少”。

2. **success / done / reset 的实现**（尤其是 `_hold_steps` 的实际值与计算方式）
   你文档里出现过“需≥10”的说法。
   但补充数据里 success 更像在 9 左右触发。把这块对齐后，很多指标解释会更干净。

3. **初始状态随机化范围**（x/y/yaw 分布、是否有 hard case 采样）
   失败 rollout 一上来 y_err 就是 0.5m 级别；如果这是常见初始分布的一部分，那“先对齐再插”的奖励门控会非常关键；如果这是极端 tail，可以考虑课程/重采样去先学会，再逐步放开。

4. **碰撞/接触相关的观测与惩罚**
   你现在“深插上限被碰撞卡住”的迹象很强；如果策略在碰撞态仍能从 r_pot 拿到好处，就会被吸进死区。给我碰撞惩罚/接触信号的定义，能更精准地改“别在错误的碰撞里拿奖励”。

5. **训练时 metric 的定义代码**（yaw_near、lateral_near、frac_success_now 的统计口径）
   这样我可以帮你把“训练日志口径”与“episode 漏斗口径”做一张一一对应表，避免之后每次都要靠猜。

你已经把最难的部分（系统化实验 + 补充诊断数据）做出来了；下一步就是把“长尾失败”这个坏家伙揪出来狠狠干——一旦它倒下，你的 yaw 均值、lateral 均值、`frac_success` 这种 step 指标会一起变好，属于“一刀切三条 KPI”的那种收益。
