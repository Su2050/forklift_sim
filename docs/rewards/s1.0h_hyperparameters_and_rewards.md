# S1.0h 训练超参数与奖励机制详解

> **实施日期**: 2026-02-08
> **核心文件**: `env_cfg.py`, `env.py`（位于 `forklift_pallet_insert_lift_project/isaaclab_patch/...`）

## 零、仿真环境修复（S1.0h 前置条件）

### 0.1 托盘参数修正

S1.0g 存在严重的托盘参数错误，导致仿真环境与实际模型不匹配：

| 参数 | S1.0g（错误） | S1.0h（正确） | 参考文档 |
|------|--------------|--------------|---------|
| `scale` | `(4.0, 4.0, 4.0)` | `(1.8, 1.8, 1.8)` | `isaac_sim_asset_import.md` |
| `pallet_depth_m` | `4.8m` | `2.16m`（= 1.2m x 1.8） | 同上 |
| `mass` | `30.0kg` | `45.0kg` | 同上 |
| `init_state.pos[2]` | `0.30m` | `0.15m` | 同上 |
| `robot init pos[0]` | `-6.0m` | `-3.5m` | 适配 1.8x 缩放 |

### 0.2 `_pallet_front_x` 符号 bug 修复

**严重度**: 致命（插入奖励永远为 0）

```python
# 修复前（S1.0g）— 指向托盘远端面
self._pallet_front_x = pos[0] + pallet_depth_m * 0.5  # = 0.0 + 2.4 = +2.4

# 修复后（S1.0h）— 正确指向 pocket 开口（近端面）
self._pallet_front_x = pos[0] - pallet_depth_m * 0.5  # = 0.0 - 1.08 = -1.08
```

叉车从 -X 方向接近，pocket 开口在托盘的 -X 面。修复前 `insert_depth = tip_x - (+2.4)` 永远为负（被 clamp 到 0）。

### 0.3 碰撞物理修复

1. **添加 `collision_props`**（`env_cfg.py`）:
   - `contact_offset=0.02`（碰撞检测提前量，防止微小穿透）
   - `rest_offset=0.005`（静止时最小间隙）

2. **显式应用 `RigidBodyAPI`**（`env.py` `_setup_pallet_physics`）:
   - Nucleus 的 `pallet.usd` 默认不带 RigidBodyAPI
   - 在 clone_environments 前显式 Apply + 设置 `kinematic=False`

3. **凸分解碰撞体**（`env.py` `_setup_pallet_physics`）:
   - 为所有 Mesh prim 设置 `convexDecomposition`（替代默认 `boundingCube`）
   - `maxConvexHulls=32`, `hullVertexLimit=64`

### 0.4 Isaac Lab API 兼容性修复

- `Prim.GetDescendants()` → `Usd.PrimRange(root_prim)`
- `write_root_pose_to_sim(pos, quat, env_ids)` → `write_root_pose_to_sim(cat([pos,quat]), env_ids)`
- `write_joint_state_to_sim(pos, vel, env_ids)` → `write_joint_state_to_sim(pos, vel, env_ids=env_ids)`

### 0.5 验证结果（2026-02-08）

- `_pallet_front_x = -1.08`（与手动计算 `0.0 - 2.16/2` 一致）
- RigidBodyAPI 成功应用（`enabled=True, kinematic=False`）
- 凸分解碰撞体已设置（`approx=convexDecomposition`）
- 阶段 1 自动接近测试中叉车可以移动

## 一、S1.0h 核心修复

### 1.1 问题诊断

**S1.0g 训练失败的根本原因**：

1. **对齐学习失败**：`E_align` 从 5.24 → 5.27（几乎不变），`w_ready` 从 0.0218 → 0.0315（始终很低）
2. **插入/举升未激活**：`insert_norm_mean ≈ 0`，`r_insert` 和 `r_lift` 全程为 0
3. **训练不稳定**：`noise_std` 从 3.02 → 13.29（+340%），策略未收敛

**死锁机制**：

- `w_ready = w_lat * w_yaw` + 严格阈值（0.10m, 10°）→ 绝大多数时间 `w_ready ≈ 0`
- `r_approach = k_approach * w_ready * delta_dist` → `w_ready ≈ 0` 时接近奖励被静音
- 不靠近 → `k_align` 上不来（近处才更大）→ 对齐学不动 → `w_ready` 起不来 → 接近奖励又被关掉

### 1.2 修复方案

S1.0h 采用"先打通对齐闭环，再堵奖励泵漏洞"的策略：

1. **修复对齐学习闭环**（优先级最高）：
   - r_approach 软门控（0.2 + 0.8*w_ready）
   - 对齐阈值随距离插值（远处松、近处紧）
   - yaw 目标分两段（远处对准指向托盘方向，近处对准托盘朝向）
   - r_forward 绑定到朝向因子（w_yaw）

2. **修复奖励泵漏洞**（必须）：
   - 插入奖励：势函数 shaping（带 gamma）
   - 举升奖励：势函数 shaping（带 gamma）
   - reset 时正确初始化势能缓存

## 二、S1.0h PPO训练超参数

### 2.1 核心超参数配置

S1.0h 的 PPO 超参数与 S1.0g 保持一致：

| 超参数 | S1.0h值 | 说明 |
|--------|---------|------|
| **`num_envs`** | **1024** | 并行环境数 |
| **`num_steps_per_env`** | **64** | 每个环境收集的步数 |
| **`num_learning_epochs`** | **5** | 每次更新时的epoch数 |
| **`num_mini_batches`** | **4** | mini-batch数量 |
| **`clip_param` (ε)** | **0.2** | PPO裁剪范围 |
| **`learning_rate`** | **3e-4** | 初始学习率 |
| **`gamma`** | **0.99** | 折扣因子（用于势函数 shaping） |
| **`lam` (GAE λ)** | **0.95** | GAE参数 |
| **`entropy_coef`** | **0.005** | 熵系数 |
| **`init_noise_std`** | **3.0** | 初始探索噪声 |
| **`max_iterations`** | **2000** | 最大迭代次数 |

## 三、S1.0h 奖励机制详解

### 3.1 对齐阈值随距离插值

**S1.0g 问题**：
- 固定严格阈值：`lat_ready_m = 0.10m`，`yaw_ready_deg = 10.0°`
- 在 2~3m 远处过于苛刻，导致 `w_ready` 长期接近 0

**S1.0h 修复**：

```python
# 对齐阈值随距离插值（远处松、近处紧）
lat_ready_far = 0.6   # 远处宽松阈值
lat_ready_close = 0.10  # 近处严格阈值
lat_ready_m = lat_ready_far * w_far + lat_ready_close * w_close

yaw_ready_far_deg = 30.0   # 远处宽松阈值
yaw_ready_close_deg = 10.0  # 近处严格阈值
yaw_ready_deg = yaw_ready_far_deg * w_far + yaw_ready_close_deg * w_close
```

**效果**：
- 远处（`w_far ≈ 1`）：`lat_ready_m ≈ 0.6m`，`yaw_ready_deg ≈ 30°`（宽松）
- 近处（`w_close ≈ 1`）：`lat_ready_m ≈ 0.10m`，`yaw_ready_deg ≈ 10°`（严格）
- 远处 `w_ready` 不再长期接近 0，学习信号不会被饿死

### 3.2 yaw 目标分两段

**S1.0g 问题**：
- 远处就用 `|robot_yaw - pallet_yaw|` 作为 yaw 误差
- 会和"为了消除横向误差必须先打角"产生冲突

**S1.0h 修复**：

```python
# 远处：对准"指向托盘的方向"
yaw_to_target = torch.atan2(
    pallet_pos[:, 1] - root_pos[:, 1],
    pallet_pos[:, 0] - root_pos[:, 0]
)
dyaw_to_target = yaw_to_target - yaw
dyaw_to_target = (dyaw_to_target + math.pi) % (2 * math.pi) - math.pi

# 近处：对准"托盘朝向"
dyaw_to_pallet = pallet_yaw - yaw
dyaw_to_pallet = (dyaw_to_pallet + math.pi) % (2 * math.pi) - math.pi

# 距离插值
dyaw = dyaw_to_target * w_far + dyaw_to_pallet * w_close
yaw_err_deg = torch.abs(dyaw) * (180.0 / math.pi)
```

**效果**：
- 远处：允许策略先打角对准托盘方向，不会因为 yaw 误差被惩罚
- 近处：要求精确对准托盘朝向
- 减少"左右不是人"的结构性矛盾

### 3.3 r_approach 软门控

**S1.0g 问题**：
```python
r_approach = k_approach * w_ready * delta_dist
```
当 `w_ready ≈ 0` 时，接近奖励被完全静音。

**S1.0h 修复**：
```python
# 软门控，即使未对齐也允许少量接近奖励（打破死锁）
w_approach = 0.2 + 0.8 * w_ready  # 范围 [0.2, 1.0]
r_approach = k_approach * w_approach * delta_dist
```

**效果**：
- 未对齐时（`w_ready ≈ 0`）：`w_approach = 0.2`，仍有 20% 接近奖励
- 完全对齐时（`w_ready = 1`）：`w_approach = 1.0`，100% 接近奖励
- 打破死锁：允许策略在未完全对齐时也能接近，获得近处高质量对齐信号

### 3.4 r_forward 绑定到朝向因子

**S1.0g 问题**：
```python
r_forward = k_forward * w_far * torch.clamp(v_xy_r_x, min=0.0)
```
容易让策略变成"先冲再说"，而不是"边冲边把车身摆正"。

**S1.0h 修复**：
```python
# 绑定到朝向因子，避免"先冲再说"
r_forward = k_forward * w_far * w_yaw * torch.clamp(v_xy_r_x, min=0.0)
```

**效果**：
- 只有朝向正确时（`w_yaw > 0`）才给前进奖励
- 避免"先冲再说"的行为
- 更稳定的接近策略

### 3.5 插入奖励势函数 shaping

**S1.0g 问题**：
```python
progress = insert_depth - self._last_insert_depth
r_insert = k_insert * w_ready * torch.clamp(progress, min=0.0)
```
后退不扣分，可以循环刷分（奖励泵漏洞）。

**S1.0h 修复**：
```python
# 势函数 shaping（带 gamma，防止奖励泵漏洞）
gamma = 0.99  # PPO 折扣因子
Phi_insert = k_insert * w_ready * insert_norm
r_insert = gamma * Phi_insert - self._last_Phi_insert
self._last_Phi_insert = Phi_insert.detach()
```

**公式详解**：
- `k_insert`：动态系数 `[0.0, 15.0]`，随距离变化
- `w_ready`：对齐质量权重 `[0.0, 1.0]`
- `insert_norm`：归一化插入深度 `[0.0, 1.0]` = `insert_depth / 2.16m`
- `gamma`：PPO 折扣因子 `0.99`

**效果**：
- 插进去加分，拔出来扣分（势函数）
- 循环刷分无效
- 奖励信号更稳定

### 3.6 举升奖励势函数 shaping

**S1.0g 问题**：
```python
delta_lift = lift_delta - self._last_lift_pos
r_lift = k_lift * w_lift * torch.clamp(delta_lift, min=0.0)
```
下降不扣分，可以循环刷分（奖励泵漏洞）。

**S1.0h 修复**：
```python
# 势函数 shaping（带 gamma，防止奖励泵漏洞）
gamma = 0.99
lift_height = tip[:, 2] - self._fork_tip_z0  # 当前举升高度
Phi_lift = self.cfg.k_lift * w_lift * lift_height
r_lift = gamma * Phi_lift - self._last_Phi_lift
self._last_Phi_lift = Phi_lift.detach()
```

**公式详解**：
- `k_lift`：举升奖励系数，固定值 `20.0`
- `w_lift`：举升门控权重 `[0.0, 1.0]` = `w_lift_base * w_ready`
- `lift_height`：当前举升高度（单位：米）
- `gamma`：PPO 折扣因子 `0.99`

**效果**：
- 抬起来加分，放下去扣分（势函数）
- 循环刷分无效
- 奖励信号更稳定

### 3.7 reset 时正确初始化势能

**S1.0g 问题**：
reset 时把增量缓存置 0，首步可能产生异常大的奖励。

**S1.0h 实际实现**：
```python
# 在 _reset_idx 中初始化势能缓存
# reset 时 insert_depth ≈ 0、lift_height ≈ 0 → Phi ≈ 0
# 配合 _is_first_step 保护增量奖励（r_approach, r_align, pen_premature）
self._last_Phi_insert[env_ids] = 0.0
self._last_Phi_lift[env_ids] = 0.0

# E_align 使用远处阈值初始化（reset 时机器人远离托盘）
E_align_reset = y_err / lat_ready_far + yaw_err_deg / yaw_ready_far_deg
self._last_E_align[env_ids] = E_align_reset
```

**安全分析**：
- Reset 后叉车远离托盘，`insert_depth ≈ 0`、`lift_height ≈ 0`
- 因此 `Phi_insert ≈ 0`、`Phi_lift ≈ 0`，首步 `r_insert ≈ gamma * 0 - 0 = 0`
- `_is_first_step` 保护确保增量奖励（r_approach, r_align）首步不触发
- 随机初始化范围 `x ∈ [-4.0, -2.5]`，确保叉车不会在 reset 后已经过 pocket 开口

## 四、S1.0h 奖励系数配置

### 4.1 距离自适应系数（与 S1.0g 相同）

| 系数 | 远处值 | 近处值 | 说明 |
|------|--------|--------|------|
| `k_app_far` | 10.0 | 8.0 | 接近奖励系数 |
| `k_app_close` | 8.0 | 8.0 | 接近奖励系数 |
| `k_align_far` | 2.0 | 10.0 | 对齐奖励系数 |
| `k_align_close` | 10.0 | 10.0 | 对齐奖励系数 |
| `k_ins_far` | 0.0 | 15.0 | 插入奖励系数 |
| `k_ins_close` | 15.0 | 15.0 | 插入奖励系数 |
| `k_align_abs` | 0.10 | 0.10 | 绝对对齐惩罚系数 |
| `k_forward` | 0.02 | 0.02 | 远距离前进速度奖励系数 |
| `k_lift` | 20.0 | 20.0 | 举升奖励系数 |
| `k_premature_far` | 12.0 | 5.0 | 空举惩罚系数 |
| `k_premature_close` | 5.0 | 5.0 | 空举惩罚系数 |

### 4.2 对齐阈值（S1.0h 新增）

| 参数 | 远处值 | 近处值 | 说明 |
|------|--------|--------|------|
| `lat_ready_far` | 0.6m | - | 远处横向对齐阈值（宽松） |
| `lat_ready_close` | - | 0.10m | 近处横向对齐阈值（严格） |
| `yaw_ready_far_deg` | 30.0° | - | 远处偏航对齐阈值（宽松） |
| `yaw_ready_close_deg` | - | 10.0° | 近处偏航对齐阈值（严格） |

### 4.3 距离阈值

| 参数 | 值 | 说明 |
|------|-----|------|
| `d_far` | 2.6m | 远处阈值 |
| `d_close` | 1.1m | 近处阈值 |

## 五、预期效果

### 5.1 对齐学习闭环修复

**修复前（S1.0g）**：
- `w_ready` 始终 ≈0.03（被严格阈值锁死）
- `r_approach` 几乎为 0（被 `w_ready` 静音）
- `dist_front` 改善有限（3.07m → 2.38m）

**修复后（S1.0h）**：
- 远处 `w_ready` 上升（宽松阈值 0.6m, 30°）
- `r_approach` 出现（软门控允许 20% 基础奖励）
- `dist_front` 快速下降（目标 <1.6m）
- `E_align` 开始下降（目标 <1.0）

### 5.2 奖励泵漏洞修复

**修复前（S1.0g）**：
- 插入：往前插得分，往后退不扣分
- 举升：抬起来得分，放下去不扣分

**修复后（S1.0h）**：
- 插入：插进去加分，拔出来扣分（势函数）
- 举升：抬起来加分，放下去扣分（势函数）
- 循环刷分无效

## 六、与 S1.0g 对比

| 特性 | S1.0g | S1.0h |
|------|-------|-------|
| **对齐阈值** | 固定严格（0.10m, 10°） | 距离自适应（远处松、近处紧） |
| **yaw 目标** | 固定对准托盘朝向 | 分两段（远处对准指向方向，近处对准朝向） |
| **r_approach 门控** | 硬门控（w_ready） | 软门控（0.2 + 0.8*w_ready） |
| **r_forward** | 只看前进速度 | 绑定到朝向因子（w_yaw） |
| **r_insert** | clamp(progress, min=0) | 势函数 shaping（带 gamma） |
| **r_lift** | clamp(delta_lift, min=0) | 势函数 shaping（带 gamma） |
| **reset 势能** | 置 0 | 初始化为当前状态 |

## 七、关键指标监控

### 7.1 对齐阶段指标

- **`w_ready`**：目标 >0.1（修复前 ≈0.03）
- **`dist_front_mean`**：目标 <1.6m（修复前 ≈2.38m）
- **`E_align`**：目标 <2.0（修复前 ≈5.27）
- **`yaw_deg_mean`**：目标 <5°（修复前 ≈12°）

### 7.2 插入/举升阶段指标

- **`r_insert`**：目标 >0（修复前 =0）
- **`r_lift`**：目标 >0（修复前 =0）
- **`insert_norm_mean`**：目标 >0（修复前 ≈0）
- **`w_lift`**：目标 >0（修复前 =0）

### 7.3 训练稳定性指标

- **`noise_std`**：目标稳定或下降（修复前从 3.02 → 13.29）
- **`frac_aligned`**：目标上升（修复前 ≈3%）

## 八、实施建议

1. **立即实施第一阶段修复**：
   - r_approach 软门控
   - 对齐阈值随距离插值

2. **监控关键指标**：
   - `w_ready` 是否上升（目标 >0.1）
   - `dist_front` 是否下降（目标 <1.6m）
   - `E_align` 是否下降（目标 <2.0）
   - `r_insert` 是否出现（目标 >0）

3. **如果第一阶段效果良好**：
   - 继续实施 yaw 目标分两段和 r_forward 改进
   - 然后实施势函数修复

4. **如果效果不佳**：
   - 考虑调整软门控系数（0.2 + 0.8*w_ready 中的 0.2）
   - 考虑调整对齐阈值范围（lat_ready_far, yaw_ready_far_deg）

## 九、训练与验证命令

### 9.1 安装到 IsaacLab

```bash
cd /home/uniubi/projects/forklift_sim
bash forklift_pallet_insert_lift_project/scripts/install_into_isaaclab.sh /home/uniubi/projects/forklift_sim/IsaacLab
```

### 9.2 启动 S1.0h 训练（从零开始）

```bash
conda deactivate  # 必须退出 conda，使用 Isaac Sim 自带 Python 3.11
cd /home/uniubi/projects/forklift_sim/IsaacLab
TERM=xterm ./isaaclab.sh -p scripts/reinforcement_learning/rsl_rl/train.py \
    --task Isaac-Forklift-PalletInsertLift-Direct-v0 \
    --headless --num_envs 1024 \
    --run_name exp_s1.0h
```

### 9.3 验证环境（headless）

```bash
conda deactivate
cd /home/uniubi/projects/forklift_sim/IsaacLab
TERM=xterm ./isaaclab.sh -p ../scripts/verify_forklift_insert_lift.py --headless
```

### 9.4 S1.0h 新增日志指标

| 指标 | 含义 | 预期范围 |
|------|------|---------|
| `s0/lat_ready_m` | 当前距离下的横向对齐阈值 | 0.10 ~ 0.60 |
| `s0/yaw_ready_deg` | 当前距离下的偏航对齐阈值 | 10.0 ~ 30.0 |
| `s0/w_approach` | r_approach 软门控权重 | 0.20 ~ 1.00 |
| `s0/k_insert_eff` | 有效插入奖励系数 | 8.0 ~ 15.0 |
| `phi/Phi_insert` | 插入势函数值 | >= 0 |
| `phi/Phi_lift` | 举升势函数值 | >= 0 |

## 十、文件变更清单

| 文件 | 变更类型 | 说明 |
|------|---------|------|
| `env_cfg.py` | 修改 | 托盘参数修正(scale/depth/mass/pos)、添加 collision_props、S1.0h 对齐阈值参数 |
| `env.py` | 修改 | _pallet_front_x 修复、S1.0h 全部奖励改进、API 兼容性修复、详细注释 |
| `scripts/verify_forklift_insert_lift.py` | 恢复 | 从 git d4bf472 恢复验证脚本 |
| `s1.0h_hyperparameters_and_rewards.md` | 新建/更新 | 本文档 |
