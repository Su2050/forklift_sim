# 后轮转向符号 bug 事后复盘（2026-02-16）

> 严重程度：**P0** — 转向系统完全失效，所有训练/评估结果受污染

---

## 1. Bug 描述

`env.py` 第 670-671 行：

```python
# left rotator needs opposite sign due to mirrored joint axis in USD
steer_left = -steer   # ← BUG：取反是错误的
steer_right = steer
```

代码**假设** USD 中 `left_rotator_joint` 和 `right_rotator_joint` 的关节轴方向是镜像的，
因此对左轮取反以让两轮"物理上转向同一方向"。

**实际情况**：两个关节轴方向**相同**，不是镜像。取反导致两个后轮始终指向相反方向，
转向力互相抵消，叉车几乎无法转弯。

---

## 2. 诊断证据

### 2.1 仿真实测（`diagnose_rotator_axis.py`）

| 测试 | 左轮输入 | 右轮输入 | 左轮实际角度 | 右轮实际角度 | 结论 |
|------|---------|---------|------------|------------|------|
| C: 同号 | +0.3 | +0.3 | **+7.33°** | **+16.30°** | 同号 → 同向 |
| D: 异号（当前代码） | -0.3 | +0.3 | **-13.70°** | **+11.30°** | 异号 → 反向（八字） |
| E: 同号负 | -0.3 | -0.3 | **-16.57°** | **-7.41°** | 同号 → 同向 |

**结论：同号输入→两轮同向，异号输入（当前代码）→两轮反向。关节轴不是镜像的。**

### 2.2 回放日志佐证

`play_expert` (seed=0) 数据：
- steps 0-120：`steer`≈-0.5，`lat` 从 0.567 降到 0.047 → 部分有效（单侧力未完全抵消）
- steps 130-260：`steer` 翻正≈+0.5，`lat` 从 -0.013 一路飙到 -1.25 → **完全无效**
- 效果高度不对称（一个方向部分有效，反方向完全失效），与"两轮力互相抵消"一致

### 2.3 历史诊断数据

`steering_control_analysis.md` 中记录的不对称：
- `steer=+0.3` → 实际朝向变化 **2.89°**
- `steer=-0.3` → 实际朝向变化 **14.01°**
- 同样输入量级，效果差 **5 倍**

---

## 3. 影响范围

- **所有使用 `_apply_action()` 的训练和评估**全部受影响
- 包括 s1.0k ~ s1.0t 所有版本的训练
- 包括所有 expert_v* 回放与视频
- 叉车在仿真中从未正确转过弯——策略只能靠间接方式（速度差、惯性）产生微弱转向

---

## 4. 修复

```python
# 修复前（错误）
steer_left = -steer
steer_right = steer

# 修复后（正确）
steer_left = steer
steer_right = steer
```

一行改动。去掉左轮的取反，让两轮收到相同的转向目标。

---

## 5. 根因分析：这个错误是怎么产生的

1. **写代码时凭直觉假设"左右对称关节轴一定镜像"**，没有验证就写了 `-steer`
2. 注释写得很自信：`"left rotator needs opposite sign due to mirrored joint axis in USD"`——把假设包装成了事实
3. **没有对关节轴方向做单元验证**——没有脚本在写入控制前单独测试"给左轮正角度，它往哪转"
4. **后续调试方向被注释误导**——所有后续排查都默认注释正确，从未质疑取反本身

---

## 6. 防范措施：如何避免类似错误

### 规则 1：对 USD 关节做"单轴验证"再写控制代码

**任何时候**对机器人关节写控制指令之前，必须先跑一个最小脚本：
- 只给**一个关节**设置正值目标，其他保持 0
- 在仿真中 step 若干步
- 读出实际关节角度，确认正方向
- 对称关节（左/右）分别测试，确认是否镜像

```python
# 模板：单轴验证
robot.set_joint_position_target([[+0.3]], joint_ids=[left_id])
robot.set_joint_position_target([[0.0]], joint_ids=[right_id])
# step 100 次
actual_left = robot.data.joint_pos[0, left_id]
# 再反过来测 right
```

### 规则 2：注释中区分"已验证事实"和"假设"

- 已验证 → `# VERIFIED: left axis is Z-up, tested by diagnose_rotator_axis.py`
- 未验证 → `# ASSUMPTION: mirrored axis — TODO: verify with single-axis test`

禁止把未验证的假设写成陈述句，尤其是涉及符号/方向的。

### 规则 3：新增关节控制映射时，必须附带验证脚本

在 `scripts/` 下建立对应的验证脚本（如 `diagnose_rotator_axis.py`），
并在 PR / commit message 中注明验证结果。代码审查时可以复现。

### 规则 4：对称关节的符号处理，默认从"同号"开始

除非有明确的单轴测试证据，否则左右对称关节的控制目标应默认使用**相同符号**。
如果需要取反，必须在注释中写明验证来源。

### 规则 5：关键控制链路变更后，跑"转向对称性冒烟测试"

冒烟测试内容：
- `steer=+0.3` 运行 30 步，记录 yaw 变化
- `steer=-0.3` 运行 30 步，记录 yaw 变化
- 两个 yaw 变化应该**大小相近、符号相反**
- 如果不对称超过 30%，标记为阻断问题

---

## 7. 时间线

| 时间 | 事件 |
|------|------|
| 早期（s1.0k 之前） | `steer_left = -steer` 被加入代码，注释声称"镜像轴" |
| s1.0k ~ s1.0t | 所有训练均在转向失效状态下运行 |
| 2026-02-16 | 用户观察 expert_v7 视频发现后轮方向异常 |
| 2026-02-16 | `diagnose_rotator_axis.py` 确认关节轴不是镜像，取反为 bug |

---

## 8. 教训总结

> **不要相信注释，相信仿真数据。**
>
> 对物理仿真中的符号/方向问题，必须用**最小可验证实验**确认，
> 而不是凭直觉或类比推断。写注释时区分"假设"和"已验证事实"。
> 这一行取反浪费了数周的训练算力和调参时间。
