# 诊断报告：托盘举升尾部拖地问题及终极解决方案

**日期：** 2026-02-22
**问题现象：** 在强化学习训练或手动控制测试中，叉车能够成功将货叉插入托盘并执行举升动作，但托盘在被举起后，其远离叉车的一端（尾部）始终下垂并拖在地上，无法实现水平举升。

## 1. 根本原因分析 (Root Cause)

经过详尽的物理极限测试以及直接提取并渲染 3D 模型的顶点数据，确定该问题源于**仿真环境中的设备尺寸缩放错配导致力矩失衡**，以及**托盘内部物理几何的阻挡**。

具体数据支撑与真相：
1. **重心位置 (Center of Mass)：** 当前官方托盘（`pallet.usd`）原本深 1.2m。由于为了匹配大尺寸叉车，在代码中配置了 `scale=(1.8, 1.8, 1.8)`，导致其深度被强行拉长为 2.16 米。因此，它的物理重心位于 **1.08 米** 处。
2. **隐藏的内部阻挡柱：** 官方模型并不是一个简单的空心木架。在其内部（深度 52% 的正中间位置），有一排横向的内部木垫块/立柱。
3. **凸分解膨胀卡死 (Convex Decomposition Wedging)：** 叉车的货叉本身长度约为 0.958 米。理论上应该能插到底，但当宽大的货叉插入到托盘深度 52% 处时（即接触到中间的内部立柱时），由于物理引擎凸分解算法自动生成的“碰撞保护壳（Contact Offset）”膨胀，导致货叉在正中间被狭窄的孔洞死死卡住（Wedged）。
   - 在 `scale=1.8` 下，52% 的位置大约对应 **0.938 米** 的极限插入深度。
4. **力矩失衡导致拖地：** 因为物理上被卡死在最大插入深度（0.938m），货叉的尖端始终无法越过托盘的物理重心（1.08m）。叉车提供的向上举升力作用点永远在重心的前方。这就导致托盘必然产生“头轻脚重”的力矩，尾部受重力影响自然下垂拖地。

## 2. 现实与仿真的差异：为什么真实世界不拖地？

这个问题极度反直觉：“为什么必须要放大 1.8 倍货叉才能插进去？既然插进去了又够不到重心，那真实世界里的叉车是怎么工作的？”

**答案是：现实中的叉车货叉，根本没有仿真里这个 3D 模型这么“肥胖”！这是导致所有尴尬连锁反应的万恶之源。**

*   **现实世界的标准匹配：** 真实的木托盘插孔宽度约为 22~23 厘米。而真实的标准叉车，单根货叉（钢齿）的宽度通常只有 **10~15 厘米**。因此，15厘米宽的货叉可以极其轻松地插入 23厘米的孔洞。同时，真实货叉长度通常在 1.1~1.2 米，能够贯穿整个 1.2 米深的托盘，完美越过 0.6 米处的重心，绝对不会拖地。
*   **仿真世界的模型失调：** NVIDIA 提供的 `forklift_c.usd` 模型，其单根货叉宽度居然达到了夸张的 **39.4 厘米（394mm）**！这在现实中是用来铲集装箱或巨型钢卷的特种重型尺寸。而 `pallet.usd` 却是一个标准的 22.8 厘米孔宽的木托盘。
*   **用魔法打败魔法的代价：** 为了把近 40 厘米粗的巨型铁齿，硬塞进 22 厘米的标准孔里，代码中执行了一个现实中不可能实现的操作——**把整个托盘等比放大了 1.8 倍（`scale=1.8`）**。
    *   孔宽变成了 `22.8 × 1.8 = 41 cm`，货叉终于能进去了。
    *   **代价：** 原本 1.2 米深的正常托盘，变成了 **2.16 米** 的巨无霸，重心退到了 1.08 米。而那根巨宽的货叉长度却只有不到 1 米（0.958m）。
*   **结论：** 仿真引擎完美复刻了物理定律——如果你让一个师傅用不到 1 米的短货叉，去挑起一个 2.16 米长、重心在 1.08 米处的巨型木板，尾部必然会因为“头重脚轻”而下垂拖地。

## 3. 失败的尝试与验证

为了在不修改模型和重心的前提下解决问题，我们进行了以下尝试，进一步证明了根本原因：

- **尝试修改代码参数 (`insert_fraction=0.45`)：** 无效。代码配置无法打破 PhysX 物理引擎底层的刚体碰撞检测限制。
- **等比缩小托盘 (`scale=(1.5, 1.5, 1.5)`)：** 深度缩短到了 1.8m。但等比缩放导致托盘的**插孔变窄**，宽大的货叉在入口处就被物理卡死（最大插入深度变为 0.000m）。
- **非等比缩小托盘 (`scale=(1.5, 1.8, 1.8)`)：** 保持了插孔的宽度，仅缩短深度为 1.8m（重心变为 0.9m）。但因为那排隐藏的内部柱子位于 52% 深度处，随着托盘缩短，柱子也跟着往前移了！结果货叉在 0.795m 处就被提前卡住（0.795m < 0.9m重心），依然未能越过重心，拖地问题依旧。
- **通过代码覆盖加长货叉 (USD Xform Override)：** 只拉长了“视觉网格 (Visual Mesh)”，底层的“碰撞刚体 (Collision Body)”并没有跟着变长。

## 4. 终极解决方案

通过上述排查，我们得出了两条彻底解决此问题的有效路径。**强烈推荐使用方案 A（成本最低且即时生效）。**

### 方案 A：物理引擎“黑客”法 —— 人为平移物理重心（当前采用）

**原理：** 既然一切的起因是“把托盘放大了导致重心后移”，而我们又不希望去 3D 软件里重做模型，我们可以直接调用 USD 物理 API，强行把这个巨型托盘的“物理重心（Center of Mass）”向货叉方向平移一段距离，欺骗物理引擎。

1. **执行 Python 脚本偏移重心：**
   使用我们编写的 `scripts/shift_pallet_com.py` 脚本（内含 `UsdPhysics.MassAPI`），直接修改官方 `pallet.usd`，将重心在 X 轴上向叉车方向强行平移 20 厘米（-0.2m），并另存为 `pallet_com_shifted.usd`。
2. **效果：**
   原本 1.08m 的重心被偏移到了 **0.88m** 处。此时，货叉即便依旧被卡在 0.938m 的位置，但其支撑点已经**越过**了新的物理重心（0.938m > 0.88m）。
3. **环境配置更新：**
   修改 `env_cfg.py`，将资产路径指向新文件，保持 `scale=(1.8, 1.8, 1.8)` 不变：
   ```python
   usd_path=f"{os.environ.get('ISAACLAB_PATH', '')}/../assets/pallet_com_shifted.usd"
   ```
**结论：** 叉车现在可以完美、水平地举起这个托盘，拖地问题彻底解决，且无需任何外部 3D 软件介入。

---

### 方案 B：3D 建模手术法 —— 物理移除内部阻挡柱

**原理：** 从根源上消除物理阻挡，让货叉能够 100% 长驱直入。

1. **导出与修改模型：**
   - 使用 3D 建模软件（如 **Blender**）导入 `pallet.usd`。
   - 在编辑模式下，找到位于托盘深度 50% 处的**那排中间木垫块/立柱**，选中顶点并将其**彻底删除**，让插孔从头到尾畅通无阻。
   - 导出为新的 USD 文件（例如 `pallet_hollow.usd`）。
2. **Isaac Sim 碰撞重置：**
   - 在 Isaac Sim 的 GUI 中打开刚导出的 `pallet_hollow.usd`，确保其碰撞近似（Collision Approximation）重新设置为 `convexDecomposition`，让引擎基于新镂空形状重新生成碰撞体。
3. **环境配置更新：**
   - 使用新模型，并配合非等比缩放 `scale=(1.5, 1.8, 1.8)` 将托盘深度缩短至 1.8m（重心 0.9m）。
   - 去掉中间阻挡后，0.958m 的货叉能插满全长，轻松越过 0.9m 重心，从而实现水平举升。